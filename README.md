# 📝 Point 서비스 동시성 제어 보고서

## 1. 개요
동시성 제어(Concurrency Control)는 여러 사용자의 요청이 동시에 처리될 때 **데이터의 무결성과 일관성**을 보장하기 위한 기법이다.  
이번 과제의 핵심 문제는 **동일 사용자가 동시에 충전/사용 요청을 보낼 때 잔액과 거래 이력의 불일치**가 발생할 수 있다는 점이었다.  

따라서 이번 구현에서는 **동일 사용자 요청은 직렬화**, **서로 다른 사용자 요청은 병렬 처리**되도록 설계하여,  
데이터 정확성과 시스템 처리량(Throughput)을 동시에 확보하고자 했다.

---

## 2. 동시성 제어의 중요성
- **데이터 무결성 보장**  
  → 동일 사용자 요청이 동시에 들어와도 잔액과 이력이 항상 일치해야 한다.
- **충돌 방지**  
  → 두 요청이 같은 데이터를 동시에 수정하지 못하도록 제어해야 한다.
- **성능 최적화**  
  → 서로 다른 사용자의 요청은 병렬로 처리해 시스템 자원을 최대한 활용한다.
- **사용자 경험 개선**  
  → 일관된 API 응답 규약(성공 시 200, 잘못된 요청 시 400, 잔액 부족 시 409)을 보장한다.

---

## 3. 주요 동시성 제어 방식
시스템 설계에서 고려할 수 있는 대표적인 방식은 다음과 같다.

### 3.1 로킹
- **배타적 잠금 (Exclusive Lock)**: 쓰기 시 사용, 동시에 하나의 요청만 가능  
- **공유 잠금 (Shared Lock)**: 읽기 시 사용, 동시에 여러 요청 가능  
- 장점: 구현이 단순하고 충돌 예방 효과가 크다.  
- 단점: 교착 상태 위험과 성능 저하가 발생할 수 있다.

### 3.2 타임스탬프
- 요청에 시간 순서를 부여하고, 충돌 시 롤백으로 해결  
- 장점: 교착 상태가 발생하지 않는다.  
- 단점: 롤백/재실행으로 인한 성능 비용이 크다.

### 3.3 낙관적 검증
- 실행 중에는 잠금 없이 진행하고, 커밋 시 충돌 검증  
- 장점: 읽기 위주 환경에서 효율적  
- 단점: 충돌이 많은 환경에서는 성능이 급격히 저하될 수 있다.

### 3.4 MVCC (Multi-Version Concurrency Control)
- 데이터를 여러 버전으로 관리해 읽기는 잠금 없이 처리  
- 장점: 읽기 성능과 병행성이 매우 높다.  
- 단점: 버전 관리에 따른 오버헤드와 쓰기 복잡도가 크다.

---

## 4. 본 과제에서 채택한 방식: **ReentrantLock per User**

이번 과제에서는 데이터베이스 레벨의 락 대신, **애플리케이션 레벨에서 사용자 단위로 `ReentrantLock`을 관리**하는 방식을 채택했다.  

### 왜 이 방식을 채댁한 이유
- **단순성**: 단일 인스턴스를 전제로 한 과제 상황에서 가장 단순하고 빠르게 적용 가능합니다.
- **요구사항 충족**: 동일 사용자 요청은 직렬화, 다른 사용자 요청은 병렬 처리 → 정확성과 성능을 동시에 만족한다.  
- **테스트 가능성**: JUnit 기반의 동시성 테스트(`PointConcurrencyTest`)로 문제를 재현·검증할 수 있다.

### 설계 포인트
- `ConcurrentHashMap<Long, ReentrantLock>`으로 사용자별 락을 캐싱
- `lock.lock(); try { … } finally { lock.unlock(); }` 패턴으로 항상 안전하게 해제
- `fair=true` 옵션으로 동일 사용자 요청 간 순서 보장(기아 방지)
- 임계 구역 최소화: read → 계산 → 잔액 갱신 → 히스토리 기록 `(new ReentrantLock(true))`

### 4.3 장단점  
| 장점                           | 단점                                 |
|--------------------------------|-------------------------------------|
| 구현 단순성                    | 락 객체 캐시 관리 필요 (장기 미사용 시 메모리 점유 가능성) |
| 효과적인 데이터 무결성 보장    | 멀티 인스턴스(분산 환경)에서 동작 보장 불가 (Redis, DB 락 필요) |
| 사용자 간 병렬성 유지로 처리량 저하 최소화 | 퍼포먼스 튜닝 시 고려사항 존재        |

---

## 5. 테스트로 검증한 시나리오

### 단일 사용자 동시 충전
- **목표**: 하나의 사용자가 동시에 여러 번 충전했을 때, 최종 잔액이 올바르게 계산되는가?  
- **검증**: 10개 스레드 × 100원 충전 → 최종 잔액 1000원  
- **의미**: 동일 사용자에 대한 직렬화가 정상적으로 동작함을 확인
```java
int threads = 10;
long amount = 100;

for (int i = 0; i < threads; i++) {
    tasks.add(() -> {
        ready.countDown();
        start.await();
        service.charge(USER_ID, amount);
        done.countDown();
        return null;
    });
}

done.await();
assertThat(service.get(USER_ID).point()).isEqualTo(threads * amount);
```
### 다중 사용자 혼합 요청
- **목표**: 서로 다른 사용자가 동시에 요청할 때, 서로 간섭 없이 독립적으로 처리되는가?  
- **검증**: U1, U2가 동시에 충전/사용해도 각자 잔액이 독립적으로 보장됨  
- **의미**: 사용자 단위 직렬화가 올바르게 분리되어 있음을 확인
```java
for (int i = 0; i < threads; i++) {
            tasks.add(() -> {
                ready.countDown(); start.await(); service.charge(U1, amount); done.countDown(); return null;
            });
            tasks.add(() -> {
                ready.countDown(); start.await(); service.charge(U2, amount); done.countDown(); return null;
            });
        }
```
### 플래키 방지
- **문제**: 단순 반복 호출 방식은 타이밍에 따라 성공/실패가 달라져 테스트가 신뢰성이 없었다.  
- **해결**: `CountDownLatch`를 활용하여 모든 스레드를 동시에 시작·종료  
- **의미**: 동시성 문제를 **안정적으로 재현 가능**하게 만들고, 테스트를 신뢰할 수 있게 된다.

```java
CountDownLatch ready = new CountDownLatch(threads * 2);
CountDownLatch start = new CountDownLatch(1);
CountDownLatch done  = new CountDownLatch(threads * 2);

ready.await();    
start.countDown();
done.await();
```
